import argparse 
import json
import pandas as pd
import statsmodels.stats.multitest as ssm



"""
This script combine all json file generated by the HyPhy aBSREL model and calculate a mutlitesting correction
The output is a file combing the tests for all genes 

command:

    python combine_pos_sell_info_absrel.py --files_possel < list of json file from HyPhy> --files_sat_subst <list of file for sat subst> --prefix_out <prefix for ouput file>

"""


def map_inputs(jsons:list, confidents:list, sat_substs:list)-> dict:
    """
    This function map together json file and saturation of substitution file

    :param jsons: list of json fles
    :param sat_substs: list of saturaiton of substitution files
    :return: Dictionary that map json file tot he corresponding saturations substtitution file
    """
    dico_result = {}
    for json in jsons:
        id_json = json.split("/")[-1].split(".ABSREL")[0]
        for sta_subst in sat_substs:
            id_sta_subst = sta_subst.split("/")[-1].split(".nuc")[0]
            if id_json == id_sta_subst:
                dico_result[id_json] = [json, sta_subst,""]
        for conf in confidents:
            id_conf =  conf.split("/")[-1].split(".confident")[0]
            if id_json == id_conf:
                dico_result[id_json][2] = conf
    return dico_result


def get_max_rate(rates:list)->list:
    """
    """
    max = 0.0
    freq = 0.0
    for rate in rates:
        if float(rate[0]) > max:
            max = float(rate[0])
            freq = float(rate[1])
    return [max, freq]

def get_pos_diversifying(positions:list, map_conf_to_all:list)->list:
    """
    """
    posterior_diversifying = positions[1]
    i = 0
    result = []
    for pos in posterior_diversifying:
        if float(pos) > 0.5:
            orig_pos = map_conf_to_all[i]
            result.append([orig_pos, float(pos)])
        i = i +1
    return  result      

def fetch_pos_sel_info(gene_id:str, json_file:str, conf_file:str, sat_subst:str)->dict:
    """
    Retrieve the positive selction information fomr the json file

    :param gene_id: the gene id 
    :param json_file: JSON file from positive selction analysis
    :return: dictionary of results
    """
    lst_val = []
    with open(sat_subst) as sat_subst_handler:
        for line in sat_subst_handler:
            if "exp_entrop" in line:
                continue
            lst_val = line.split()
            break
    print (json_file)
    with open(json_file) as json_handler:
        file_contents = json_handler.read()
        
    parsed_json = json.loads(file_contents)

    map_conf_to_all = map_confident_to_all(conf_file)
    
    # gee if is contained in the file name
    #gene_id = json_file.split("/")[-1].split(".nuc")[0]
    result = {}
    for (branch,values) in parsed_json["branch attributes"]['0'].items():
        if not "original name" in values:
            continue
        species_name = values["original name"].split("|")[-1]
        pval = values['Uncorrected P-value']
        if pval is None:
            continue
        pval_corr = values['Corrected P-value']
        rate_class = values['Rate classes']
        rate_dist = values['Rate Distributions']
        max_rate =  get_max_rate(rate_dist)
        pos_diversifying = [] 
        if 'posterior' in values:
            posterior = values['posterior']
            pos_diversifying = get_pos_diversifying(posterior, map_conf_to_all)
        lrt = values['LRT']
        omega_ratio_base = values['Baseline MG94xREV omega ratio']
        base = values['Baseline MG94xREV']
        #if not pval is None:
        positions = ""
        if pos_diversifying != []: 
            positions_pos_sel = [f"{x[0]}:{x[1]}" for x in pos_diversifying]
            positions = "|".join(positions_pos_sel)
        result[species_name] = [gene_id, lrt, pval, pval_corr, rate_class, max_rate[0],max_rate[1], base, positions, float(lst_val[-1]), float(lst_val[2]), float(lst_val[1])]
    return result

def _create_data_frame(pos_sel_branches:dict)->dict:
    """
    This function create a dataframe fromt the matrix of postive selection informaton associated
    to each branch/species in the input dictionary.

    :param pos_sel_branches: dictionary storing the information matrix for each species/branch tested
    :return: a dictionary with data frame instead of matrix associated to each branch/species tested.
    """
    result = {}
    for branche, pos_val in pos_sel_branches.items():
        df = pd.DataFrame(pos_val,  columns =  ["gene_id", "lrt", "pval", "pval_corr", 
                                                "rate_class", "max_omega","freq_site", "base", "position", "Pval_no_sat", "obs_entropy", "exp_entropy" ])
        result[branche] = df
    return result

def multitetesting_correction(pos_sel_branches_df:dict, method:str="fdr_bh")->dict:
    """
    This function performed a multitesting correction
    
    :param pos_sel_branches_df: the dictionary that store for each branch/species a 
                                dataframe with the positicve selection results 
    :param method: the method to be used for multitesting correction
    :return: dictionary of that store the postive selction data for each branch/species
             including the adjusted pvalues.
    """
    for branch, values_df in pos_sel_branches_df.items():
        pval = values_df["pval_corr"]
        rej, pval_adj, alphasidak, alphacBonf = ssm.multipletests(pval, method=method)
        values_df["pval_adj"] = pval_adj
    return pos_sel_branches_df


def get_file_list(file:str)->list:
    """
    """
    result = []
    with open(file) as file_handler:
        for line_file in file_handler:
                file = line_file.replace("[","").replace("]","").replace(",","").replace("\n", "")
                result.append(file)
    return result

def map_confident_to_all(confident:str)-> list:
    """
    """
    regions = []
    with open(confident) as file_handler:
        for line in file_handler:
            tab = line.split()
            regions.append([int(tab[0]), int(tab[-1])])
    
    mapping =[]
    for region in regions:
        i = region[0]
        while i < regions[1]:
            mapping.append(i)
            i = i + 1
    return mapping



def main(files:str, file_sat_subst:str, confident_file:str, pref_out:str)->None:
    """
    The main fucntion of the script

    :param files: string that list all json files to be parsed separated by a white space
    :param file_sat_subst: the list fo file with substitution saturaiton info
    :param pref_out: prefix used for the file name
    """
    jsons = get_file_list(files) #files.split()
    subst_sats = get_file_list(file_sat_subst)#.split()
    confidents = get_file_list(confident_file)

    dico_input = map_inputs(jsons, confidents, subst_sats)

    pos_sel_branches = {}
    for id, files in dico_input.items():
        json = files[0]
        sat_subst = files[1]
        conf_file = files[2]
        pos_sel = fetch_pos_sel_info(id, json, conf_file, sat_subst)
        for (species, val) in pos_sel.items():
            if not species in pos_sel_branches:
                pos_sel_branches[species] = []
            pos_sel_branches[species].append(val)
    
    #converting array to pandas df
    pos_sel_branches_df = _create_data_frame(pos_sel_branches)
    
    # mutli testtin correction
    pos_sel_branches_mlt = multitetesting_correction(pos_sel_branches_df)
   
    #save the file per branche
    for branche, df in pos_sel_branches_mlt.items():
        file_name = f"{pref_out}_{branche}.possel"
        df.to_csv(file_name,sep="\t")


########################################################################################
########### Main script
########################################################################################

parser = argparse.ArgumentParser(description='Script formating the data to be handle by the positvie selction pipeline')
parser.add_argument('--files_possel',type=str, help='list of json file to integrate')
parser.add_argument('--files_sat_subst',type=str, help='list of files for saturation_substitution')
parser.add_argument('--confident', type=str, help='confident region file. ')
parser.add_argument('--prefix_out', type=str, help='prefix for outfiles')

args = parser.parse_args()
main(args.files_possel, args.files_sat_subst,args.confident, args.prefix_out)

